---
id: upgradability 
title: Upgrading Programs
sidebar_label: Upgrading Programs
---

# A Developer's Guide to Upgradability in Leo

This guide provides a practical overview of Aleo's program upgradability framework, tailored for developers using the Leo language. You'll learn how to configure your program, implement common upgrade patterns, and follow best practices for writing secure, maintainable applications.
For more details on the underlying protocol, refer to the [Aleo docs](TODO).

## 1. Getting Started: The `program.json` File

Your program's upgrade policy is defined in the `program.json` file. The Leo compiler reads the `upgrade` object to understand your intent and generate the appropriate underlying code.

There are four primary upgrade modes:

| Mode | Description |
| :--- | :--- |
| `noupgrade` | **Default.** The program is not upgradable. |
| `admin` | Upgrades are controlled by a single, hardcoded admin address. |
| `checksum` | Upgrades are governed by an on-chain checksum, often managed by a separate program (e.g., a DAO). |
| `custom` | You write the entire upgrade logic from scratch in the `constructor`. |

## 2. Core Mechanics

Upgradability revolves around a special `constructor` function and on-chain program metadata.

### The `constructor`

The `constructor` is a special function that runs on-chain during every deployment and upgrade. Think of it as the gatekeeper for your program.

* **It's Immutable:** The logic inside your `constructor` is set in stone at the first deployment. It can never be changed by a future upgrade. A bug here is permanent, so audit it carefully.
* **It Controls Everything:** If the `constructor` logic fails (e.g., a failed `assert`), the entire deployment or upgrade transaction is rejected.
* **It's the Key:** A program is only upgradable if it is first deployed with a `constructor`.

### Program Metadata Operands

Within a `constructor`, you can access on-chain metadata about the program using the `self` keyword.

| Operand | Leo Type | Description |
| :--- | :--- | :--- |
| `self.edition` | `u16` | The program's version number. Starts at `0` and must increment by exactly `1` for each upgrade. |
| `self.program_owner` | `address` | The address that submitted the deployment transaction. |

---

## 3. Upgrade Patterns in Leo

Here are practical recipes for each upgrade mode, including the `program.json` configuration and the corresponding Leo code.

### Pattern 1: Non-Upgradable (Default)

**Goal:** Explicitly prevent all future upgrades. This is the safest default.

**`program.json`**
```json
{
  "program": "noupgrade_example.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "MIT",
  "dependencies": null,
  "upgrade": {
    "mode": "noupgrade"
  }
}
````

**`main.leo`**

The Leo compiler automatically generates a constructor that locks the program to its initial version.

```leo
// The 'noupgrade_example' program.
program noupgrade_example.aleo {
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
    
    // This constructor is auto-generated by the compiler for the "noupgrade" mode.
    // It is immutable and prevents any future upgrades.
    async constructor() {
        assert_eq(self.edition, 0u16);
    }
}
```

### Pattern 2: Admin-Driven Upgrade

**Goal:** Restrict upgrades to a single, hardcoded admin address.

**`program.json`**

```json
{
  "program": "admin_example.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "MIT",
  "dependencies": null,
  "upgrade": {
    "mode": "admin",
    "address": "aleo1rhgdu77hgyqd3xjj8ucu3jj9r2p3lam3tc3h0nvv2d3k0rp2ca5sqsceh7"
  }
}
```

**`main.leo`**

The compiler uses the `address` from `program.json` to generate the admin-checking constructor.

```leo
// The 'admin_example' program.
program admin_example.aleo {
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }

    // This constructor is auto-generated for the "admin" mode.
    // It ensures that only the designated admin can upgrade the program.
    async constructor() {
        assert_eq(self.program_owner, aleo1rhgdu77hgyqd3xjj8ucu3jj9r2p3lam3tc3h0nvv2d3k0rp2ca5sqsceh7);
    }
}
```

### Pattern 3: Custom Logic (Time-lock Example)

**Goal:** Implement any upgrade logic you need. Here, we'll enforce a time delay before an upgrade is allowed.

**`program.json`**

```json
{
  "program": "timelock_example.aleo",
  "version": "0.1.0",
  "description": "",
  "license": "MIT",
  "dependencies": null,
  "upgrade": {
    "mode": "custom"
  }
}
```

**`main.leo`**

With `"mode": "custom"`, you are responsible for writing the entire constructor logic yourself.

```leo
// The 'timelock_example' program.
program timelock_example.aleo {
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }

    async constructor() {
        // For upgrades (edition > 0), enforce a block height condition.
        if self.edition > 0u16 {
            assert(block.height >= 1300u32);
        }
    }
}
```

### Pattern 4: Checksum-Driven (Vote Example)

**Goal:** Delegate upgrade authority to a separate governance program that manages a list of approved code checksums.

**`program.json`**

```json
{
  "program": "vote_example.aleo",
  "version": "0.1.0",
  "license": "MIT",
  "dependencies": [
    {
      "name": "basic_voting.aleo",
      "location": "local",
      "path": "./basic_voting"
    }
  ],
  "upgrade": {
    "mode": "checksum",
    "mapping": "basic_voting.aleo/approved_checksum",
    "key": "true"
  }
}
```

**`main.leo`**

The compiler uses the `mapping` and `key` fields to generate a constructor that looks up the approved checksum from the `basic_voting.aleo` program.

```leo
// The 'vote_example' program.
program vote_example.aleo {
    transition main(public a: u32, b: u32) -> u32 {
        let c: u32 = a + b;
        return c;
    }
    
    // The constructor is auto-generated by the "checksum" mode.
    // It will check that `basic_voting.aleo/approved_checksum[true]`
    // contains the checksum of this program version.
}
```

-----

## 4\. The Rules: What You Can and Cannot Change

The protocol enforces strict rules to ensure that upgrades don't break dependent applications or corrupt existing state.

An upgrade **can**:

* Change the internal logic of existing `function` and `finalize` blocks.
* Add new `struct`s, `record`s, `mapping`s, `function`s, and `closure`s.

An upgrade **cannot**:

* Change the input or output signatures of any existing `function`.
* Change the input signature of any existing `finalize` block.
* Change the logic within an existing `closure`.
* Modify or delete any existing `struct`, `record`, or `mapping`.
* Delete any existing program component.

| Program Component | Delete | Modify | Add |
| :--- | :---: | :---: | :---: |
| `import` | ❌ | ❌ | ✅ |
| `struct` | ❌ | ❌ | ✅ |
| `record` | ❌ | ❌ | ✅ |
| `mapping` | ❌ | ❌ | ✅ |
| `closure` | ❌ | ❌ | ✅ |
| `function` | ❌ | ✅ (logic) | ✅ |
| `finalize` | ❌ | ✅ (logic) | ✅ |
| `constructor` | ❌ | ❌ | ❌ |

-----

## 5\. Security Checklist

Mutability introduces new risks. Keep these points in mind.

- ✅ **Audit the `constructor` intensely.** Its logic is permanent and cannot be fixed after deployment.
- ✅ **Prefer multi-sig or DAO governance over a single admin.** A single point of failure is risky.
- ✅ **Implement time-locks for major upgrades.** Giving users a window to react builds trust.
- ✅ **Plan for "ossification".** Provide a way to make your program immutable (e.g., by transferring admin rights to a burn address) to give users long-term certainty.

## 6\. Legacy Programs: The Final Word

If you have a program that was deployed before the upgradability feature was enabled (or any program deployed without a `constructor`):

**It is permanently non-upgradable.**

There is **no migration path** to make a legacy program upgradable. If you need to add new features, you must deploy an entirely new program and have your users migrate to it.

```
```
